"""
Java Structure Listener for MCP (Model Context Protocol) Server.

This module implements an ANTLR4 parse tree listener that extracts comprehensive
structural information from Java source code. The JavaStructureListener walks
the parse tree generated by the ANTLR4 Java parser and builds detailed representations
of Java code elements including classes, interfaces, enums, records, methods, fields,
constructors, and their associated metadata.

The listener follows the Visitor pattern through ANTLR4's listener mechanism,
providing enter/exit hooks for each relevant parse tree node type. It maintains
context about nested structures and associates extracted Javadoc comments with
the appropriate code elements.

Key Features:
- Extracts all Java type declarations (classes, interfaces, enums, records)
- Captures complete method signatures including parameters and exceptions
- Processes field declarations with modifiers and initial values
- Handles nested/inner classes with proper parent-child relationships
- Associates Javadoc comments with corresponding code elements
- Extracts Java annotations and access modifiers
- Preserves source line numbers for all elements
- Supports modern Java language features (records, etc.)

Integration:
- Used by JavaSourceParser as the primary structure extraction mechanism
- Produces structured data using types from java_mcp.types module
- Designed for seamless integration with MCP server protocols
- Coordinates with JavaDocExtractor for documentation association

Author: Rubens Gomes
License: Apache-2.0
"""

from typing import List

from java_mcp.java.types import Class, Method, Field, Parameter
from java_mcp.parser.antlr4 import JavaParser, JavaParserListener

class JavaStructureListener(JavaParserListener):
    """
    ANTLR4 parse tree listener that extracts comprehensive Java code structure.

    This listener implements the ANTLR4 listener pattern to walk Java parse trees
    and extract detailed structural information about classes, methods, fields, and
    other Java language constructs. It maintains context about nested structures
    and builds a complete representation of the Java code hierarchy.

    The listener processes the parse tree in a depth-first manner, maintaining
    a stack of currently active classes to handle nested type declarations properly.
    It extracts metadata including modifiers, annotations, documentation, line numbers,
    inheritance relationships, and type parameters.

    Attributes:
        classes (List[Class]): List of top-level Class objects extracted from the source.
                              Nested classes are stored within their parent's inner_classes list.
        current_package (str): The package declaration found in the source file.
                              Empty string if no package declaration exists.
        import_statements (List[str]): List of all import statements found in the source,
                                      including static imports marked with "static" prefix.
        class_stack (List[Class]): Internal stack tracking currently active class contexts
                                  for handling nested type declarations properly.
        recent_javadoc (str | None): Most recently encountered Javadoc comment that hasn't
                                   been associated with a code element yet.
        javadocs (Dict[int, str]): Dictionary mapping line numbers to Javadoc content,
                                  populated by JavaSourceParser for association.

    Example:
        # Used internally by JavaSourceParser
        lexer = JavaLexer(input_stream)
        parser = JavaParser(CommonTokenStream(lexer))
        tree = parser.compilationUnit()

        listener = JavaStructureListener()
        listener.javadocs = extracted_javadocs  # Set by parser

        walker = ParseTreeWalker()
        walker.walk(listener, tree)

        # Access results
        for cls in listener.classes:
            print(f"Class: {cls.name} with {len(cls.methods)} methods")

    Note:
        This listener is designed to be stateful during a single parse operation
        but should be recreated for each new parsing task to ensure clean state.
        The listener assumes well-formed Java source code as input.
    """

    def __init__(self):
        """
        Initialize the JavaStructureListener with empty collections.

        Sets up all the necessary data structures for tracking Java code elements
        during parse tree traversal. The listener starts with empty collections
        and builds them as it encounters relevant parse tree nodes.

        All collections are initialized to empty states and will be populated
        during the tree walking process through the various enter/exit methods.
        """
        self.classes: List[Class] = []
        self.current_package = ""
        self.import_statements = []
        self.class_stack = []  # Stack to handle nested classes
        self.recent_javadoc = None

    def enterPackageDeclaration(self, ctx: JavaParser.PackageDeclarationContext):
        """
        Extract and store the package declaration from the parse tree.

        This method is called when the listener encounters a package declaration
        in the Java source. It extracts the fully qualified package name and
        stores it for association with all classes found in this compilation unit.

        Args:
            ctx (JavaParser.PackageDeclarationContext): ANTLR4 parse tree context
                                                       containing the package declaration node.

        Example:
            For source code: "package com.example.model;"
            Sets self.current_package = "com.example.model"

        Note:
            Java allows only one package declaration per source file, so this
            method will be called at most once during parsing of a single file.
        """
        if ctx.qualifiedName():
            self.current_package = ctx.qualifiedName().getText()

    def enterImportDeclaration(self, ctx: JavaParser.ImportDeclarationContext):
        """
        Extract and store import statements from the parse tree.

        This method processes both regular and static import declarations,
        extracting the fully qualified import names and adding them to the
        import statements list. Static imports are marked with a "static" prefix.

        Args:
            ctx (JavaParser.ImportDeclarationContext): ANTLR4 parse tree context
                                                      containing the import declaration node.

        Example:
            For "import java.util.List;" -> adds "java.util.List"
            For "import static java.lang.Math.PI;" -> adds "static java.lang.Math.PI"

        Note:
            Import statements are collected in the order they appear in the source
            file. Wildcard imports (.*) are preserved as-is in the import name.
        """
        if ctx.qualifiedName():
            import_name = ctx.qualifiedName().getText()
            if ctx.STATIC():
                import_name = f"static {import_name}"
            self.import_statements.append(import_name)

    def enterClassDeclaration(self, ctx: JavaParser.ClassDeclarationContext):
        """
        Process class declarations and extract comprehensive class information.

        This method handles the entry into class declaration nodes, extracting
        all relevant information including name, modifiers, annotations, inheritance
        relationships, and documentation. It delegates to the generic type declaration
        handler for consistent processing across all type kinds.

        Args:
            ctx (JavaParser.ClassDeclarationContext): ANTLR4 parse tree context
                                                     containing the class declaration node.

        Example:
            For "public final class User extends AbstractUser implements Serializable"
            Extracts: name="User", modifiers=["public", "final"], extends="AbstractUser",
                     implements=["Serializable"], class_type="class"

        Note:
            This method pushes the new class onto the class_stack to handle
            any nested type declarations that may follow.
        """
        self._enter_type_declaration(ctx, "class")

    def enterInterfaceDeclaration(self, ctx: JavaParser.InterfaceDeclarationContext):
        """
        Process interface declarations and extract comprehensive interface information.

        Similar to class declarations, but specifically for interface types.
        Interfaces have different semantics (all methods implicitly abstract,
        extends vs implements relationships) but are processed using the same
        generic type declaration framework.

        Args:
            ctx (JavaParser.InterfaceDeclarationContext): ANTLR4 parse tree context
                                                         containing the interface declaration node.

        Example:
            For "public interface Repository<T> extends BaseRepository"
            Extracts: name="Repository<T>", modifiers=["public"], extends="BaseRepository",
                     class_type="interface"
        """
        self._enter_type_declaration(ctx, "interface")

    def enterEnumDeclaration(self, ctx: JavaParser.EnumDeclarationContext):
        """
        Process enum declarations and extract comprehensive enum information.

        Handles Java enum type declarations, which are special classes that
        extend java.lang.Enum implicitly. Enums can have constructors, methods,
        and fields in addition to their enum constants.

        Args:
            ctx (JavaParser.EnumDeclarationContext): ANTLR4 parse tree context
                                                    containing the enum declaration node.

        Example:
            For "public enum Status implements Comparable<Status>"
            Extracts: name="Status", modifiers=["public"], implements=["Comparable<Status>"],
                     class_type="enum"
        """
        self._enter_type_declaration(ctx, "enum")

    def enterRecordDeclaration(self, ctx: JavaParser.RecordDeclarationContext):
        """
        Process record declarations and extract comprehensive record information.

        Handles Java 14+ record type declarations, which are special classes that
        provide a compact syntax for immutable data carriers. Records automatically
        generate constructors, accessors, equals, hashCode, and toString methods.

        Args:
            ctx (JavaParser.RecordDeclarationContext): ANTLR4 parse tree context
                                                      containing the record declaration node.

        Example:
            For "public record Point(int x, int y) implements Serializable"
            Extracts: name="Point", modifiers=["public"], implements=["Serializable"],
                     class_type="record"

        Note:
            Record components (the parameters in the record header) are typically
            processed as both constructor parameters and field declarations.
        """
        self._enter_type_declaration(ctx, "record")

    def _enter_type_declaration(self, ctx, class_type: str):
        """
        Generic method to handle all types of Java type declarations.

        This unified method processes classes, interfaces, enums, and records
        using a common extraction framework. It extracts all standard type
        information including names, modifiers, annotations, inheritance
        relationships, and documentation, then creates appropriate Class objects.

        The method handles nested type declarations by maintaining a class stack
        and properly associating inner types with their enclosing types.

        Args:
            ctx: ANTLR4 parse tree context for any type declaration node.
                Can be ClassDeclarationContext, InterfaceDeclarationContext,
                EnumDeclarationContext, or RecordDeclarationContext.
            class_type (str): The type of Java construct being processed.
                            One of: "class", "interface", "enum", "record".

        Processing Steps:
            1. Extract type name from identifier
            2. Collect modifiers (public, private, static, final, etc.)
            3. Extract annotations (@Entity, @Component, etc.)
            4. Get source line number for location tracking
            5. Process inheritance relationships (extends/implements)
            6. Create Class object with all extracted information
            7. Handle nesting by adding to parent or top-level list
            8. Push onto class_stack for processing nested elements

        Example:
            For a nested class:
            "public static final class InnerClass extends BaseClass"
            Creates Class object with proper nesting relationship preserved.

        Note:
            This method consumes any recent_javadoc and associates it with
            the new type declaration, then resets it to None.
        """
        class_name = ctx.identifier().getText() if ctx.identifier() else "Unknown"

        # Extract modifiers
        modifiers = []
        if hasattr(ctx.parentCtx, 'classOrInterfaceModifier'):
            for mod_ctx in ctx.parentCtx.classOrInterfaceModifier():
                modifiers.append(mod_ctx.getText())

        # Extract annotations
        annotations = self._extract_annotations(ctx.parentCtx)

        # Get line number
        line_number = ctx.start.line if ctx.start else 0

        # Extract extends/implements
        extends = None
        implements = []

        if hasattr(ctx, 'typeType') and ctx.typeType():
            extends = ctx.typeType().getText()

        if hasattr(ctx, 'typeList') and ctx.typeList():
            for type_ctx in ctx.typeList().typeType():
                implements.append(type_ctx.getText())

        # Create class object
        new_class = Class(
            name=class_name,
            package=self.current_package,
            modifiers=modifiers,
            annotations=annotations,
            javadoc=self.recent_javadoc,
            line_number=line_number,
            methods=[],
            fields=[],
            inner_classes=[],
            extends=extends,
            implements=implements,
            class_type=class_type
        )

        # Handle nested classes
        if self.class_stack:
            self.class_stack[-1].inner_classes.append(new_class)
        else:
            self.classes.append(new_class)

        self.class_stack.append(new_class)
        self.recent_javadoc = None

    def exitClassDeclaration(self, ctx):
        """
        Handle completion of class declaration processing.

        Called when the listener finishes processing a class declaration and
        all its nested content. Pops the class from the class_stack to restore
        the previous nesting context.

        Args:
            ctx: ANTLR4 parse tree context for the class declaration being exited.
        """
        self._exit_type_declaration()

    def exitInterfaceDeclaration(self, ctx):
        """
        Handle completion of interface declaration processing.

        Called when the listener finishes processing an interface declaration
        and all its nested content. Delegates to the generic exit handler.

        Args:
            ctx: ANTLR4 parse tree context for the interface declaration being exited.
        """
        self._exit_type_declaration()

    def exitEnumDeclaration(self, ctx):
        """
        Handle completion of enum declaration processing.

        Called when the listener finishes processing an enum declaration
        and all its nested content. Delegates to the generic exit handler.

        Args:
            ctx: ANTLR4 parse tree context for the enum declaration being exited.
        """
        self._exit_type_declaration()

    def exitRecordDeclaration(self, ctx):
        """
        Handle completion of record declaration processing.

        Called when the listener finishes processing a record declaration
        and all its nested content. Delegates to the generic exit handler.

        Args:
            ctx: ANTLR4 parse tree context for the record declaration being exited.
        """
        self._exit_type_declaration()

    def _exit_type_declaration(self):
        """
        Generic method to handle exiting any type declaration.

        This method is called when finishing the processing of any type
        declaration (class, interface, enum, record). It pops the current
        type from the class_stack to restore the previous nesting context,
        allowing proper handling of nested type declarations.

        The method ensures that subsequent type members are associated
        with the correct enclosing type or added to the top-level types list.

        Note:
            This method safely handles the case where the class_stack might
            be empty, though this shouldn't occur in well-formed Java code.
        """
        if self.class_stack:
            self.class_stack.pop()

    def enterMethodDeclaration(self, ctx: JavaParser.MethodDeclarationContext):
        """
        Extract comprehensive method information from method declarations.

        This method processes regular method declarations (not constructors),
        extracting all relevant information including name, return type, parameters,
        modifiers, annotations, exception declarations, and documentation.

        The extracted information is used to create Method objects that are
        added to the currently active class in the class_stack.

        Args:
            ctx (JavaParser.MethodDeclarationContext): ANTLR4 parse tree context
                                                      containing the method declaration node.

        Processing Steps:
            1. Extract method name from identifier
            2. Determine return type (void or specific type)
            3. Process formal parameter list
            4. Collect access modifiers and other modifiers
            5. Extract method-level annotations
            6. Process throws clause for exception declarations
            7. Get source line number for location tracking
            8. Associate any recent Javadoc documentation
            9. Create Method object and add to current class

        Example:
            For "@Override public List<String> getNames(boolean sorted) throws IOException"
            Extracts: name="getNames", return_type="List<String>",
                     parameters=[Parameter("sorted", "boolean", [])],
                     modifiers=["public"], annotations=["@Override"],
                     throws_exceptions=["IOException"]

        Note:
            This method only processes if there's an active class context
            (class_stack is not empty). Methods outside class contexts are ignored.
        """
        if not self.class_stack:
            return

        method_name = ctx.identifier().getText() if ctx.identifier() else "Unknown"

        # Extract return type
        return_type = "void"
        if ctx.typeTypeOrVoid():
            return_type = ctx.typeTypeOrVoid().getText()

        # Extract parameters
        parameters = []
        if ctx.formalParameters() and ctx.formalParameters().formalParameterList():
            parameters = self._extract_parameters(ctx.formalParameters().formalParameterList())

        # Extract modifiers
        modifiers = []
        if ctx.parentCtx and hasattr(ctx.parentCtx, 'modifier'):
            for mod_ctx in ctx.parentCtx.modifier():
                modifiers.append(mod_ctx.getText())

        # Extract annotations
        annotations = self._extract_annotations(ctx.parentCtx)

        # Extract throws clause
        throws_exceptions = []
        if ctx.qualifiedNameList():
            for name_ctx in ctx.qualifiedNameList().qualifiedName():
                throws_exceptions.append(name_ctx.getText())

        # Get line number
        line_number = ctx.start.line if ctx.start else 0

        method = Method(
            name=method_name,
            return_type=return_type,
            parameters=parameters,
            modifiers=modifiers,
            annotations=annotations,
            javadoc=self.recent_javadoc,
            line_number=line_number,
            throws_exceptions=throws_exceptions
        )

        self.class_stack[-1].methods.append(method)
        self.recent_javadoc = None

    def enterConstructorDeclaration(self, ctx: JavaParser.ConstructorDeclarationContext):
        """
        Extract comprehensive constructor information from constructor declarations.

        This method processes constructor declarations, which are special methods
        that initialize new instances of a class. Constructors have no return type
        but can have parameters, modifiers, annotations, and exception declarations.

        Constructors are represented as Method objects with is_constructor=True
        and return_type set to the class name.

        Args:
            ctx (JavaParser.ConstructorDeclarationContext): ANTLR4 parse tree context
                                                           containing the constructor declaration node.

        Processing Steps:
            1. Extract constructor name (should match class name)
            2. Set return type to constructor name (class instantiation)
            3. Process formal parameter list
            4. Collect access modifiers
            5. Extract constructor-level annotations
            6. Process throws clause for exception declarations
            7. Get source line number for location tracking
            8. Associate any recent Javadoc documentation
            9. Create Method object with is_constructor=True
            10. Add to current class's methods list

        Example:
            For "public User(String name, int age) throws ValidationException"
            Extracts: name="User", return_type="User",
                     parameters=[Parameter("name", "String", []), Parameter("age", "int", [])],
                     modifiers=["public"], is_constructor=True,
                     throws_exceptions=["ValidationException"]

        Note:
            Constructors are stored alongside regular methods in the class's
            methods list, distinguished by the is_constructor flag.
        """
        if not self.class_stack:
            return

        constructor_name = ctx.identifier().getText() if ctx.identifier() else "Unknown"

        # Extract parameters
        parameters = []
        if ctx.formalParameters() and ctx.formalParameters().formalParameterList():
            parameters = self._extract_parameters(ctx.formalParameters().formalParameterList())

        # Extract modifiers
        modifiers = []
        if ctx.parentCtx and hasattr(ctx.parentCtx, 'modifier'):
            for mod_ctx in ctx.parentCtx.modifier():
                modifiers.append(mod_ctx.getText())

        # Extract annotations
        annotations = self._extract_annotations(ctx.parentCtx)

        # Extract throws clause
        throws_exceptions = []
        if ctx.qualifiedNameList():
            for name_ctx in ctx.qualifiedNameList().qualifiedName():
                throws_exceptions.append(name_ctx.getText())

        # Get line number
        line_number = ctx.start.line if ctx.start else 0

        constructor = Method(
            name=constructor_name,
            return_type=constructor_name,  # Constructor returns instance of class
            parameters=parameters,
            modifiers=modifiers,
            annotations=annotations,
            javadoc=self.recent_javadoc,
            line_number=line_number,
            is_constructor=True,
            throws_exceptions=throws_exceptions
        )

        self.class_stack[-1].methods.append(constructor)
        self.recent_javadoc = None

    def enterFieldDeclaration(self, ctx: JavaParser.FieldDeclarationContext):
        """
        Extract comprehensive field information from field declarations.

        This method processes field (instance and class variable) declarations,
        handling multiple variable declarators in a single declaration and
        extracting type information, modifiers, annotations, and initial values.

        Java allows multiple fields to be declared in a single statement
        (e.g., "private int x, y = 5;"), so this method processes each
        variable declarator separately.

        Args:
            ctx (JavaParser.FieldDeclarationContext): ANTLR4 parse tree context
                                                     containing the field declaration node.

        Processing Steps:
            1. Extract common field type from type declaration
            2. Collect access modifiers and other modifiers (static, final, etc.)
            3. Extract field-level annotations
            4. Get source line number for location tracking
            5. Process each variable declarator for:
               - Field name extraction
               - Initial value extraction (if present)
               - Individual Field object creation
            6. Associate any recent Javadoc with all fields in declaration
            7. Add Field objects to current class

        Example:
            For "@Column private static final String NAME = \"default\", OTHER;"
            Creates two Field objects:
            - Field(name="NAME", type="String", initial_value="\"default\"", ...)
            - Field(name="OTHER", type="String", initial_value=None, ...)
            Both share: modifiers=["private", "static", "final"], annotations=["@Column"]

        Note:
            All fields in a single declaration share the same type, modifiers,
            and annotations, but may have different names and initial values.
        """
        if not self.class_stack:
            return

        # Extract field type
        field_type = ctx.typeType().getText() if ctx.typeType() else "Unknown"

        # Extract modifiers
        modifiers = []
        if ctx.parentCtx and hasattr(ctx.parentCtx, 'modifier'):
            for mod_ctx in ctx.parentCtx.modifier():
                modifiers.append(mod_ctx.getText())

        # Extract annotations
        annotations = self._extract_annotations(ctx.parentCtx)

        # Get line number
        line_number = ctx.start.line if ctx.start else 0

        # Extract variable declarators (field names and initial values)
        if ctx.variableDeclarators():
            for var_ctx in ctx.variableDeclarators().variableDeclarator():
                field_name = var_ctx.variableDeclaratorId().getText()
                initial_value = None

                if var_ctx.variableInitializer():
                    initial_value = var_ctx.variableInitializer().getText()

                field = Field(
                    name=field_name,
                    type=field_type,
                    modifiers=modifiers,
                    annotations=annotations,
                    javadoc=self.recent_javadoc,
                    line_number=line_number,
                    initial_value=initial_value
                )

                self.class_stack[-1].fields.append(field)

        self.recent_javadoc = None

    def _extract_parameters(self, param_list_ctx) -> List[Parameter]:
        """
        Extract method or constructor parameters from formal parameter list.

        This method processes formal parameter lists, handling both regular
        parameters and varargs parameters. It extracts parameter names, types,
        and annotations for each parameter in the list.

        Java supports varargs (variable arguments) as the last parameter in
        a parameter list, denoted with "..." syntax. This method handles both
        regular parameters and varargs parameters appropriately.

        Args:
            param_list_ctx: ANTLR4 parse tree context for a formal parameter list.
                           Can contain multiple formalParameter nodes and optionally
                           one lastFormalParameter node for varargs.

        Returns:
            List[Parameter]: List of Parameter objects representing all parameters
                           in the formal parameter list, including proper handling
                           of varargs parameters marked with "..." suffix.

        Processing Steps:
            1. Process regular parameters (formalParameter nodes)
               - Extract parameter type and name
               - Collect parameter-level annotations
               - Create Parameter objects
            2. Process varargs parameter (lastFormalParameter node)
               - Extract type and add "..." suffix to indicate varargs
               - Extract parameter name and annotations
               - Create Parameter object with varargs type notation

        Example:
            For parameter list "(String name, @NotNull List<User> users, int... numbers)"
            Returns: [
                Parameter("name", "String", []),
                Parameter("users", "List<User>", ["@NotNull"]),
                Parameter("numbers", "int...", [])
            ]

        Note:
            Parameter annotations are collected and preserved in the Parameter objects.
            Varargs parameters are marked with "..." appended to their type name.
        """
        parameters = []

        # Handle regular parameters
        if param_list_ctx.formalParameter():
            for param_ctx in param_list_ctx.formalParameter():
                param_type = param_ctx.typeType().getText() if param_ctx.typeType() else "Unknown"
                param_name = param_ctx.variableDeclaratorId().getText() if param_ctx.variableDeclaratorId() else "Unknown"

                # Extract parameter annotations
                annotations = self._extract_annotations(param_ctx)

                parameters.append(Parameter(
                    name=param_name,
                    type=param_type,
                    annotations=annotations
                ))

        # Handle varargs parameter
        if param_list_ctx.lastFormalParameter():
            param_ctx = param_list_ctx.lastFormalParameter()
            param_type = param_ctx.typeType().getText() if param_ctx.typeType() else "Unknown"
            param_name = param_ctx.variableDeclaratorId().getText() if param_ctx.variableDeclaratorId() else "Unknown"

            # Mark as varargs
            param_type += "..."

            # Extract parameter annotations
            annotations = self._extract_annotations(param_ctx)

            parameters.append(Parameter(
                name=param_name,
                type=param_type,
                annotations=annotations
            ))

        return parameters

    def _extract_annotations(self, ctx) -> List[str]:
        """
        Extract Java annotations from a parse tree context.

        This utility method extracts annotation information from various parse
        tree contexts that can contain annotations (classes, methods, fields,
        parameters, etc.). It handles all standard Java annotation forms.

        Java annotations can appear in many contexts and can have various forms:
        - Simple annotations: @Override
        - Annotations with single value: @SuppressWarnings("unchecked")
        - Annotations with multiple parameters: @Column(name="user_id", nullable=false)

        Args:
            ctx: ANTLR4 parse tree context that may contain annotation nodes.
                 The context should have an 'annotation' attribute if annotations
                 are present.

        Returns:
            List[str]: List of annotation strings as they appear in the source code,
                      including the @ symbol and any parameters. Empty list if no
                      annotations are found or if the context is None.

        Example:
            For context containing "@Override", "@SuppressWarnings(\"unchecked\")"
            Returns: ["@Override", "@SuppressWarnings(\"unchecked\")"]

        Note:
            The annotations are returned as complete strings including parameters,
            preserving the exact syntax from the source code for maximum fidelity.
        """
        annotations = []
        if ctx and hasattr(ctx, 'annotation'):
            for ann_ctx in ctx.annotation():
                annotations.append(ann_ctx.getText())
        return annotations
